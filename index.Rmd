---
title: "TP_Decision_Theory"
author: "Arnaud Frering"
date: "20/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r,}
library('GA')
```

#1
## 1.1

The database has 8 attributes :

1. Sequence Name: Accession number for the SWISS-PROT database
2. mcg: McGeoch's method for signal sequence recognition.
3. gvh: von Heijne's method for signal sequence recognition.
4. lip: von Heijne's Signal Peptidase II consensus sequence score. Binary attribute.
5. chg: Presence of charge on N-terminus of predicted lipoproteins. Binary attribute.
6. aac: score of discriminant analysis of the amino acid content of outer membrane and periplasmic proteins.
7. alm1: score of the ALOM membrane spanning region prediction program.
8. alm2: score of ALOM program after excluding putative cleavable signal regions from the sequence.

The class is the localisation site which can be :

1. cp: cytoplasm
2. im: inner membrane without signal sequence
3. imS: inner membrane, cleavable signal sequence
4. imL: inner membrane lipoprotein
5. imU: inner membrane, uncleavable signal sequence
6. om: outer membrane
7. omL: outer membrane lipoprotein
8. pp: periplasm


## 1.2

```{r}
data_ecoli = read.table("ecoli.data",header = FALSE, sep = "")
names(data_ecoli) = c('Sequence Name', 'mcg', 'gvh', 'lip', 'chg', 'aac', 'alm1', 'alm2', 'Class')
```

```{r}
print(data_ecoli)
```

```{r,}
class <- as.data.frame(table(data_ecoli$Class))
data_ecoli <- data_ecoli[data_ecoli$Class %in% class$Var1[class$Freq>=6],]
index_train <- rep(c(T,F), length.out=327)
train_data <- data_ecoli[which(index_train), 2:8]
test_data <- data_ecoli[which(!index_train),2:8]
train_labels <- data_ecoli[which(index_train), 9]
test_labels <- data_ecoli[which(!index_train), 9]
```

#2
##2.1

```{r}
library('class')

Ypred <- knn(train_data, test_data, cl=train_labels, k=10)
conf_matrix <- table(Ypred, test_labels)
accuracy <- function(confusion_matrix){sum(diag(confusion_matrix)/(sum(rowSums(confusion_matrix)))) * 100}
acc_knn <- accuracy(conf_matrix)

print(acc_knn)

```

##2.2

```{r}
library('evclass')

init <- EkNNinit(train_data, train_labels)
train_labels_matrix <- as.matrix(train_labels)
fit <- EkNNfit(train_data, train_labels_matrix, K=10)
EvYpred <- EkNNval(train_data, train_labels_matrix, test_data, 10, test_labels, fit$param)
M1 <- EvYpred$m
```
```{r}

print(M1)

```

#3
##3.1
```{r}
#Definition de la loss function avec beta = 1

Loss<-function(A, theta, beta=1){
  resultat = 1
  elements_A = sum(decimal2binary(A))
  if (binary2decimal(decimal2binary(theta,20) & decimal2binary(A,20))!=0){
    resultat = 1 - ((1+beta^2)/((beta^2)+elements_A))
  }
  resultat #la fonction retourne le rÃ©sultat
}

```

```{r}
# Initialisation de la matrice de loss
nb_classes = 5
nb_sous_ensembles = 2^nb_classes -1

LOSS <- matrix(rep(c(0),nb_classes*nb_sous_ensembles), nb_sous_ensembles,nb_classes)

for (i in 1:nb_classes){
  for (j in 1:nb_sous_ensembles){
    LOSS[j,i] = Loss(A = j, theta = i)
  }
  }
```

```{r}
library(plot.matrix)
plot(LOSS)

```

##3.2

```{r}
load("M2")

```

##4
#4.1

```{r}
Corr<- function (delta, theta) {
  resultat = 0
  if (binary2decimal(decimal2binary(theta,20) & decimal2binary(delta,20))!=0){
    resultat = 1
  }
  resultat
}

Rel<- function(delta, theta){
  resultat = 0
  elements_delta = sum(decimal2binary(delta))
  if (binary2decimal(decimal2binary(theta,20) & decimal2binary(delta,20))!=0){
    resultat = 1/elements_delta
  }
}
```


##5
#5.1
```{r}
dempster.comb<- function(m1, m2){
  n1 = length(m1)
  n2 = length(m2)
  grand_theta = max(n1,n2)
  m1n2 = c(rep(0,grand_theta))
  somme_vide = 0
  for (i in 1:n1){
    for (j in 1:n2){
      if (binary2decimal(decimal2binary(i,20) & decimal2binary(j,20))==0){
        somme_vide = somme_vide + (m1[i]*m2[j])
      }
    }
  }
  kappa = 1/(1-somme_vide)
  
  for(k in 1:grand_theta){
    somme_k = 0
    for (i in 1:n1){
      for (j in 1:n2){
        if (binary2decimal(decimal2binary(i,20) & decimal2binary(j,20))==k){
        somme_k = somme_k + (m1[i]*m2[j])
        }
      }
    }
    m1n2[k] = kappa*somme_k
  }
  
  m1n2
}
```

```{r}
m1 = c(0.5, 0, 0, 0.4, 0, 0, 0.1)
m2 = c(0, 0, 0, 0.5, 0.6, 0, 0)
dempster.comb(m1, m2)
```



